--- 
layout: post
title: Clojure and Selenium
---


<h2 id="sec-1">Clojure and Selenium </h2>
<div class="outline-text-2" id="text-1">



</div>

<div class="outline-3" id="outline-container-1_1">
<h3 id="sec-1_1">Motivation </h3>
<div class="outline-text-3" id="text-1_1">


<p>
I needed a kind of crawler to go around a list of pages, invoke some
javascript and collect that output.
</p>

<p>
Curl or a regular http lib’s don’t do the trick because i need to run
javascript on each requested page. For that i can use Selenium,
Selenium is a great framework to perform web testing, that uses
directly a browser and thus we can run Javascript.
</p>

<p>
Selenium can be scripted from Java which matches very well with my
wish to learn Clojure :)
</p>
</div>

</div>

<div class="outline-3" id="outline-container-1_2">
<h3 id="sec-1_2">Solution </h3>
<div class="outline-text-3" id="text-1_2">


<p>
What i implemented is not really a crawler in the sense that it does
not go around automatically following all the links it finds, it
actually gets the list of links to check from the site sitemap.xml.
But is not that hard to use this as a base for a crawler.
</p>
<p>
As some sitemaps.xml are huge, i added also a little pick-a-sample
function that randomly selects only a subset from all the sitemap.
</p>
</div>

</div>

<div class="outline-3" id="outline-container-1_3">
<h3 id="sec-1_3">Code </h3>
<div class="outline-text-3" id="text-1_3">


<p>
Im on the process of learning Clojure, so probably a lot of things
could be improved.
</p>
<p>
For Selenium, we need first to start the server, then the client, and
then use the client to browse the pages. As is not very elegant to
have a start server and“start client on the top of the script and
a“stop client and stop server call at the end of the script, i've
wrapped those around a macro (one of the major strengths of Lisp
like languages).
</p>
<p>
The whole thing goes like this:
</p>
<p>
process-sitemap receives a sitemap, transforms it into a map(with
xml-to-zip), collects the url links in it, then picks a sample from
them(with pick-a-sample) and calls check-pages with them.
</p>
<p>
check-pages gets a list of urls. It starts by using the macro, obtains
a-browser from it, then iterates over the list of urls, calling
check-a-page on each url(a-url). Note that at this point the standard
output is redirected to a file, so i can log the results from
check-a-page.
</p>
<p>
check-a-page gets a-browser and a-url, so you can guess what it will
do :)It opens that url in the browser, calls the javascript, and
prints to standard output the return of the js call.
</p>
<p>
Hope google does not mind to use their site as an example. But do not
run this on Google site, its just an example, use it on your own site!
</p>
<p>
For this to run you will need to have in your classpath a bunch of jar
libs, this is how my lib folder looks like:
</p>



<pre class="example">lib/
  clojure-contrib.jar
  clojure.jar
  jline-0.9.94.jar
  selenium-java-client-driver.jar
  selenium-server.jar
</pre>



<p>
I called this app“/coverager/
</p>
<p>
Code: 
</p>



<pre class="src src-clojure">;;file: coverager.clj
(ns coverager
  (:import (com.thoughtworks.selenium DefaultSelenium)
    (org.openqa.selenium.server SeleniumServer)
      java.util.Date
      (java.io FileWriter)
      (java.text SimpleDateFormat))
  (:use clojure.contrib.zip-filter.xml)
  (:require [clojure.zip :as zip]
            [clojure.xml :as xml]))

(defmacro with-selenium
  [browser &amp; body]
  `(let [server# (new SeleniumServer)]
    (.start server#)
    (let [~browser 
         (new DefaultSelenium <span style="color: #8b2252;">"localhost"</span>, 4444, <span style="color: #8b2252;">"*firefox"</span>, <span style="color: #8b2252;">"http://www.google.com/"</span>)]
      (.start ~browser)
      (.setTimeout ~browser <span style="color: #8b2252;">"100000"</span>)
      ~@body
      (.stop ~browser))
      (.stop server#)))

(def *js-eval* <span style="color: #8b2252;">"this.browserbot.getCurrentWindow().document.title;"</span>)                                                                                    
(defn check-a-page [a-browser a-url] 
  (try 
  (.open a-browser a-url)
    (Thread/sleep 3000) ; make a little timeout, to avoid overloading server
    (println (str a-url <span style="color: #8b2252;">","</span> (.getEval a-browser *js-eval*)))
    (catch Exception e 
    (println (str a-url <span style="color: #8b2252;">","</span> e)))))

(defn check-pages [url-list]
  (with-selenium browser
    (binding [*out* (FileWriter. 
         (str <span style="color: #8b2252;">"output/log_"</span> (.format (SimpleDateFormat. <span style="color: #8b2252;">"yyyy-MM-dd"</span>) (Date.)) <span style="color: #8b2252;">".csv"</span>))]
      (doseq [a-url url-list]
        (check-a-page browser a-url)))))

(defn xml-to-zip [url]
  <span style="color: #8b2252;">"read xml url into a tree"</span>
  (zip/xml-zip (xml/parse url)))

(defn pick-a-sample [a-percentage a-list]
  <span style="color: #8b2252;">"picks a subset (a-)percentage of the total"</span>
    (filter #(if (&gt; (rand) (- 1 (/ a-percentage 100))) %) a-list))

(defn process-sitemap [sitemap-url]
  (let [u-list (xml-&gt; (xml-to-zip sitemap-url) :url :loc text)]
    (check-pages (pick-a-sample 1 u-list))))

(def *sitemap* <span style="color: #8b2252;">"http://www.google.com/sitemap.xml"</span>)

;use: (process-sitemap *sitemap*)
</pre>



<p>
And of course tests for it:
</p>



<pre class="src src-clojure">;;file: coverager_test.clj
(ns coverager_test
  (:use clojure.contrib.test-is)
  (:use coverager)
  (:use clojure.contrib.zip-filter.xml)
  (:require [clojure.zip :as zip]
            [clojure.xml :as xml]))

(deftest browse-page
  (with-selenium abrowser  
    (.open abrowser <span style="color: #8b2252;">"http://www.google.com/a/"</span>)
    (is (.startsWith (.getTitle abrowser) <span style="color: #8b2252;">"Google Apps"</span>))))

(def abit <span style="color: #8b2252;">"&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'&gt;
 &lt;url&gt;
  &lt;loc&gt;http://www.google.com/&lt;/loc&gt;
  &lt;lastmod&gt;2009-04-03&lt;/lastmod&gt;
  &lt;priority&gt;0.5000&lt;/priority&gt;
 &lt;/url&gt;
 &lt;url&gt;
  &lt;loc&gt;http://www.google.com/a&lt;/loc&gt;
  &lt;lastmod&gt;2009-04-03&lt;/lastmod&gt;
  &lt;priority&gt;0.5000&lt;/priority&gt;
 &lt;/url&gt;
&lt;/urlset&gt;
"</span>)

(deftest xml-process
  (let [res (xml-to-zip (org.xml.sax.InputSource. (java.io.StringReader. abit)))]
    (let [lis (xml-&gt; res :url :loc text)]
      (is (= (first lis) <span style="color: #8b2252;">"http://www.google.com/"</span>))
      (is (= (last lis) <span style="color: #8b2252;">"http://www.google.com/a"</span>)))))

(deftest on-picking-sample
  (let [the-sample (pick-a-sample 10 '(0 1 2 3 4 5 6 7 8 9))]
    ;not completely garanteed will take only 1, 
    ;it should, on most cases but more important is
    ;to picking up randomly a small subset from list
    ;so less than 3 items is reasonable test
        (is (&lt; (count the-sample) 3))))

(defn run-them []
  (run-tests 'coverager_test))
</pre>



</div>

</div>

<div class="outline-3" id="outline-container-1_4">
<h3 id="sec-1_4">Take away </h3>
<div class="outline-text-3" id="text-1_4">


<p>
Clojure is great! Its my opinion that on the Lisp family of languages
the code is more elegant and visually cleaner than the C family.
</p>
<p>
I don't care much for working directly with the Java language, but
working on the JVM with other languages like JRuby, Clojure, and
harnessing all the vast amount of Java libs and infrastructure out
there is a MAJOR advantage.
</p>
<p>
I suspect i will be spending more time with Clojure in future :)
</p></div>
</div>
